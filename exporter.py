# Built-in modules
import os
from xml.dom import minidom
from collections import namedtuple

# TODO: Put in a proper config file, and/or generate from installed MS version
MS_VERSION = "3.01"
PROGRAM_VERSION = "3.3.4"
PROGRAM_REVISION = "7684abe"

NoteDef = namedtuple("NoteDef", ["pitch", "tpc", "head"])
NOTEDEF_BD = NoteDef("36", "14", None)
NOTEDEF_SD = NoteDef("38", "16", None)
NOTEDEF_HH = NoteDef("42", "20", "cross")

def exportSong(song):

    # Utilities
    def addElement(name, parent, attr = [], inner_txt = None):

        e = root.createElement(name)
        for attr_pair in attr:
            e.setAttribute(attr_pair[0], attr_pair[1])

        if inner_txt:
            e.appendChild(root.createTextNode(inner_txt))

        parent.appendChild(e)

        return e

    # Create root
    root = minidom.Document()
    xml = root.createElement('museScore')
    xml.setAttribute("version", MS_VERSION)
    root.appendChild(xml)

    # Program metadata
    addElement("programVersion", xml, inner_txt=PROGRAM_VERSION)
    addElement("programRevision", xml, inner_txt=PROGRAM_REVISION)

    # Score
    score = addElement("Score", xml)
    addElement("LayerTag", score, [("id", "0"), ("tag", "default")], "")
    addElement("currentLayer", score, inner_txt="0")
    addElement("Division", score, [], "480")

    # Style
    style = addElement("Style", score, [])
    addElement("pageWidth", style, [], "8.5")
    addElement("pageHeight", style, [], "11")
    addElement("enableVerticalSpread", style, [], "1")
    addElement("Spatium", style, [], "1.74978")

    addElement("showInvisible", score, inner_txt="1")
    addElement("showUnprintable", score, inner_txt="1")
    addElement("showFrames", score, inner_txt="1")
    addElement("showMargins", score, inner_txt="0")

    addElement("metaTag", score, [("name", "arranger")], inner_txt=song.metadata.arranger)
    addElement("metaTag", score, [("name", "composer")], inner_txt=song.metadata.composer)
    addElement("metaTag", score, [("name", "copyright")], inner_txt=song.metadata.copyright)
    addElement("metaTag", score, [("name", "creationDate")], inner_txt=song.metadata.creationDate)
    addElement("metaTag", score, [("name", "lyricist")], inner_txt=song.metadata.lyricist)
    addElement("metaTag", score, [("name", "movementNumber")], inner_txt=song.metadata.movementNumber)
    addElement("metaTag", score, [("name", "movementTitle")], inner_txt=song.metadata.movementTitle)
    addElement("metaTag", score, [("name", "platform")], inner_txt=song.metadata.platform)
    addElement("metaTag", score, [("name", "poet")], inner_txt=song.metadata.poet)
    addElement("metaTag", score, [("name", "source")], inner_txt=song.metadata.source)
    addElement("metaTag", score, [("name", "translator")], inner_txt=song.metadata.translator)
    addElement("metaTag", score, [("name", "workNumber")], inner_txt=song.metadata.workNumber)
    addElement("metaTag", score, [("name", "workTitle")], inner_txt=song.metadata.workTitle)

    # Boilerplate for a drumset score
    # These were simply copied from a valid exported score
    def addXMLSnippet(path):

        # Reference XML files generated by MS have pretty XML
        # Pasting them in our own exported file creates lots of whitespace in diff
        # So, we just strip as best we can
        def cleanXMLWhiteSpace(xml_doc):
            xml_str = xml_doc.toxml()
            xml_str = xml_str.replace('\n', '')
            xml_str = xml_str.replace('\t', '')
            xml_str = xml_str.replace('>    <', '><')
            return minidom.parseString(xml_str)

        xml_doc = minidom.parse(path)
        xml_doc = cleanXMLWhiteSpace(xml_doc)
        xml_doc = xml_doc.firstChild
        score.appendChild(xml_doc)

    addXMLSnippet("ReferenceXML/OrderXML.xml")
    addXMLSnippet("ReferenceXML/PartXML.xml")

    # Staff
    staff = addElement("Staff", score, [("id", "1")])
    vbox = addElement("VBox", staff)
    addElement("height", vbox, inner_txt="10")
    text = addElement("Text", vbox)
    addElement("style", text, inner_txt="Title")
    addElement("text", text, inner_txt=song.metadata.workTitle)

    # Song data starts
    for m in song.measures:
        m._sanitize()  # Shift indices to start at 0

    needs_time_sig = True
    for m in song.measures:
        measure = addElement("Measure", staff)
        voice = addElement("voice", measure)

        # Need to add the time signature to the first measure only
        #TODO: Support for other than 4/4
        if needs_time_sig:
            timesig = addElement("TimeSig", voice)
            addElement("sigN", timesig, inner_txt="4")
            addElement("sigD", timesig, inner_txt="4")
            needs_time_sig = False

        all_times = m.hh + m.sd + m.bd  # Combine all times in the measure that contain a note
        all_times += [0, 1, 2, 3]  # Add these as separators for each time
        all_times = list(set(all_times))  # Remove duplicates
        all_times.sort()  # Will read from left to right in time

        for i, chord_time in enumerate(all_times):

            # Get time val of next note, for calc duration of current notes
            next_time = all_times[i+1] if i < len(all_times)-1 else 4

            def calc_note_dur(notes, note_time):

                # Check if note exists
                try:
                    notes.index(note_time)
                except ValueError:
                    return 0    # Note doesn't exist

                # Gap between curr time and next note time
                duration = next_time - note_time
                
                # We don't want anything longer than a quarter note
                if duration > 1:
                    duration = 1

                return duration

            hh_dur = calc_note_dur(m.hh, chord_time)
            sd_dur = calc_note_dur(m.sd, chord_time)
            bd_dur = calc_note_dur(m.bd, chord_time)
            all_durs = [hh_dur, sd_dur, bd_dur]
            all_durs = [i for i in all_durs if i != 0]

            if not all_durs:
                continue

            # Lowest duration is the value of all, because stems are connected
            chord_dur = min(all_durs)

            chord_dur_str = ""
            if chord_dur == 1.0:
                chord_dur_str = "quarter"
            elif chord_dur ==  0.5:
                chord_dur_str = "eighth"
            elif chord_dur ==  0.25:
                chord_dur_str = "16th"

            assert chord_dur_str != "", "Generating chord duration failed."

            chord = addElement("Chord", voice)
            addElement("durationType", chord, inner_txt=chord_dur_str)
            addElement("StemDirection", chord, inner_txt="up")

            def addNote(chord, noteDef):
                note = addElement("Note", chord)
                addElement("pitch", note, inner_txt=noteDef.pitch)
                addElement("tpc", note, inner_txt=noteDef.tpc)
                if noteDef.head:
                    addElement("head", note, inner_txt=noteDef.head)

            if hh_dur:
                addNote(chord, NOTEDEF_HH)
            if sd_dur:
                addNote(chord, NOTEDEF_SD)
            if bd_dur:
                addNote(chord, NOTEDEF_BD)

    # Save
    xml_str = root.toprettyxml(indent = "\t", encoding="UTF-8")
    if not os.path.exists('_output'):
        os.mkdir('_output')
    save_path = os.path.join("_output", song.metadata.fileName)
    with open(save_path, "wb") as f:
        f.write(xml_str)
